% !TEX TS-program = pdflatex
% !TEX encoding = UTF-8 Unicode

% This is a simple template for a LaTeX document using the "article" class.
% See "book", "report", "letter" for other types of document.

\documentclass[11pt]{scrartcl} % use larger type; default would be 10pt

\usepackage[utf8]{inputenc} % set input encoding (not needed with XeLaTeX)

%%% Examples of Article customizations
% These packages are optional, depending whether you want the features they provide.
% See the LaTeX Companion or other references for full information.

%%% PAGE DIMENSIONS
\usepackage{geometry} % to change the page dimensions
\geometry{a4paper} % or letterpaper (US) or a5paper or....
% \geometry{margin=2in} % for example, change the margins to 2 inches all round
% \geometry{landscape} % set up the page for landscape
%   read geometry.pdf for detailed page layout information

\usepackage{graphicx} % support the \includegraphics command and options

% \usepackage[parfill]{parskip} % Activate to begin paragraphs with an empty line rather than an indent

%%% PACKAGES
\usepackage{booktabs} % for much better looking tables
\usepackage{array} % for better arrays (eg matrices) in maths
\usepackage{paralist} % very flexible & customisable lists (eg. enumerate/itemize, etc.)
\usepackage{verbatim} % adds environment for commenting out blocks of text & for better verbatim
\usepackage{subfig} % make it possible to include more than one captioned figure/table in a single float
\usepackage{float}
\usepackage{amssymb}

% These packages are all incorporated in the memoir class to one degree or another...

%%% HEADERS & FOOTERS
\usepackage{fancyhdr} % This should be set AFTER setting up the page geometry
\pagestyle{fancy} % options: empty , plain , fancy
\renewcommand{\headrulewidth}{0pt} % customise the layout...
\lhead{}\chead{}\rhead{}\lhead{}\chead{\textit{CS27020 Assignment: Ski Lifts and Pistes : jee22}}\rhead{}
\lfoot{\textit{Aberystwyth University}}\cfoot{\thepage}\rfoot{\textit{Computer Science}}

%%% SECTION TITLE APPEARANCE
\usepackage{sectsty}
\allsectionsfont{\sffamily\mdseries\upshape} % (See the fntguide.pdf for font help)
% (This matches ConTeXt defaults)

%%% ENVIRONMENT ITEMIZE
\newenvironment{myitemize}
{ \begin{itemize}[]
    \setlength{\itemsep}{0pt}
    \setlength{\parskip}{0pt}
    \setlength{\parsep}{0pt}     }
{ \end{itemize}                  } 

%%% ToC (table of contents) APPEARANCE
\usepackage[nottoc,notlof,notlot]{tocbibind} % Put the bibliography in the ToC
\usepackage[titles,subfigure]{tocloft} % Alter the style of the Table of Contents
\renewcommand{\cftsecfont}{\rmfamily\mdseries\upshape}
\renewcommand{\cftsecpagefont}{\rmfamily\mdseries\upshape} % No bold!

%%% END Article customizations

%%% The "real" document content comes below...

\title{Brief Article}
\author{The Author}
%\date{} % Activate to display a given date or no date (if empty),
         % otherwise the current date is printed 

\begin{document}
\newpage

\begin{center}
\textbf{\LARGE CS27020}\\[0.3cm]
\textbf{\LARGE Modelling Persistent Data}\\[0.5cm]
\textbf{\LARGE Assignment: Ski Lifts and Pistes }\\[13cm]

\begin{tabular}{ l | r }
{\large Author:} & {\large Address:} \\
James Euesden (jee22) &  Department of Computer Science \\
 & Aberystwyth University \\ 
 & Aberystwyth \\
 & Ceredigion \\
 & SY23 3DB \\
{\large Date:} \today  &  \\

\end{tabular} \\[0.2cm]

{\small Copyright Â© Aberystwyth University 2014}

\end{center}

%%%\newpage

%%%\tableofcontents

\newpage

\section{Introduction}
This task set is to build a relational database, using PostgreSQL. To begin this task, I have been provided with sample data of Pistes and Lifts, which must be viewed in Unnormalized Form (UNF), and then taken through the normalization process to reach Third Normal Form (3NF). This will be done by determining the Functional Dependencies, constructing Primary Keys and understanding other Candidate Keys, then using these to help with the normalization steps. With the resulting model, I will then create the Database, and provide suitable commands for conducting a series of queries on the database, with screenshot evidence.
\section{Analysis}
\subsection{Unnormalized Structure}
An Unnormalized Structure is data that has not been Normalized, or ready to be put safely and logically into a relational database. This is data that we might find in the 'real world' during situations where we are provided large quantities of data that, while it might make logical sense to a client, may not be appropriate to be implemented into a relational database.

Based upon the sample data provided\cite{sample}, the unnormalized structure of the Database is as follows. A thing to initially note is how there appears to be some correlation between the data in 'rise' in Lift and 'fall' in Piste. However, this only happens for a few of the entries, and with multiple values in attributes, is not something to be taken into consideration.

\subsubsection{Piste}
piste\_name\newline
grade\newline
length\_km\newline
fall\_m\newline
lif\_name\newline
piste\_open

\subsubsection{Lift}
lift\_name\newline
type\newline
summit\_m\newline
rise\_m\newline
length\_m\newline
operating

\subsection{Functional Dependencies}
A functional dependency is where data relies depends upon another piece of data in order to be determined. This can be expressed as FD: X -\textgreater \space Y. To see the functional dependencies, I made a number of assumptions about the data, based upon the sample data provided.
\subsubsection{Piste}
 \textbf{piste\_name -\textgreater  grade, length\_km, fall\_m, piste\_open}
\\[0.1cm]
We assume that this information about a Piste is functionally dependant upon the piste\_name, and this is how it should be accessed. Each attribute provides a 'fact' about the Piste, based on the piste\_name.

\textbf{piste\_name -\textgreater lift\_name}
\\[0.1cm]
In order to find the name of Lifts (lift\_name) servicing a Piste, we must know the piste\_name. However, it should be noted that Lift is in itself it's own relation. On top of this, a Lift can serve many Pistes, and so it should be noted that this could also be expressed as:\\[0.1cm]
\textbf{piste\_name \textless -\textgreater \space lift\_name}

\subsubsection{Lift}
\textbf{lift\_name -\textgreater  type, summit\_m, rise\_m, length\_m, operating}
\\[0.2cm]
Similar to Piste, we assume that the data about a Lift is functionally dependant upon lift\_name. Each of these items is functionally dependant on the lift\_name, and gives data, a 'fact', about a Lift.

\subsection{Primary \& Candidate Keys}
A Primary Key (PK) is a key that is unique to each record in a relation, and that will never be repeated in the data set. This key can be a single attribute, or a composite key, comprised of multiple attributes. This key is used as the unique identifier of a relation. When picking a Primary Key, it must conform to being unique to that relation, while also being as unchaging as possible (immutable - could change, but shouldn't) and there may also be Candidate Keys.

When deciding the Primary Keys for these relations, I found it challenging to decide the correct course of action. My initial thought was to use the piste\_name and lift\_name. However, while these are likely to be unique, it is also possible that in the future, a user may want to change or update the names, causing potential update issues. With this in mind, my choice was to make an auto-incremented integer value for both Piste and Lift in order to represent a unique identification number. These are Piste(piste\_uid) and Lift(lift\_uid).

This choice to use a UID means that a user has the freedom of adding a number of different Pistes, while still giving them the ability to alter the names of a Piste at a later date. With this considered, I decided to continue using piste\_name and lift\_name as Candidate Keys. This means that while they are not the true Primary Key, they are a Candidate for it, and it should be noted along with the functional dependencies when running the normalization process.

 It could be considered that now piste\_name and all it's functionally dependant attributes are now all functionally dependent upon piste\_uid, and the same for Lift. Since the name values are staying as Candidate keys, and the UID is merely for unique representaton purposes though, the original functional dependencies still hold.


As an extra precaution when creating the database, I will constrain the lift\_name and piste\_name to be unique, enforcing the rule that no two Pistes or Lifts should be named the same, but their names are free for change.

\newpage

\section{Normalizing the Data}
When normalizing this data, I will be dealing with each relation (Piste, Lift) separately, and will bring them together when it seems appropriate.
\subsection{First Normal Form}
The act of taking data from UNF into 1NF is by disallowing attributes to have multiple values. This means that an attribute could not contain two values, such as 2 phone numbers for one person. In the sample data provided, it can be seen that within 'Piste', there are multiple values in 'lift\_name'. This violates 1NF rule.

In order to solve this, we can move lift\_name out of the Piste and into a new relation, 'Connection'. This new relation contains the Primary Key of Piste and the attribute lift\_name. Piste no longer contains lift\_name, while otherwise staying the same. This brings Piste into 1NF.

Lift does not have any multiple values within it's attributes, nor could it be assigned any in the future. This means that Lift is already in 1NF and does not need anything doing. There are no more sets of multiple values in Lift or Piste, and Connection is also acceptable, at this stage.

The end result of the 1NF operations are below, with the current three relations shown. Those attributes \underline{underlined} represent Primary Key components. Those attributes with an asterisk (\*) are foreign keys. These relations still have some anomalies however, that will be dealt with in 2NF.

\subsubsection{Piste}
\underline{piste\_uid}\newline
piste\_name\newline
grade\newline
length\_km\newline
fall\_m\newline
open

\subsubsection{Lift}
\underline{lift\_uid}\newline
liftName\newline
type\newline
summit\_m\newline
rise\_m\newline
length\_m\newline
operating

\subsubsection{Connection}
\underline{pisteName*}\newline
\underline{length*}\newline
\underline{fall*}\newline
liftName*

(liftName references liftName from relation Lift)

\subsection{Second Normal Form}
Achieving Second Normal Form relies upon two things, the first being that 1NF is already achieved, the second being that every non-Primary Key attribute of the relation is dependent on the whole of a candidate key. As we can see from the new relation 'Connection', and our functional dependencies, liftName only depends on pisteName, not the length or fall.

In this circumstance, we would separate out piesteName and liftName into their own relation. However, since there are multiple Lifts to multiple Pistes, where a Lift can service many Pistes and a Piste can have multiple Lifts, we bring the Primary Key of each relation into a new relation, which, considering that now there is no need for Connection, we will also call Connection. This relation, Connection, is now of the Primary Keys of both Lift and Pieste, representing the Many-to-Many relationship.

This is valid with 2NF, as we can assume that the full PK of Lift and the full PK of Piste are dependent upon one another in this relation. The attributes left within Lift and Piste are wholly dependant on the Primary Key, and so are also valid. The current relationships are:

\subsubsection{Piste}
\underline{pisteName}\newline
\underline{length}\newline
\underline{fall}\newline
grade\newline
open

\subsubsection{Lift}
\underline{liftName}\newline
\underline{summit}\newline
\underline{rise}\newline
type\newline
length\newline
operating

\subsubsection{Connection}
\underline{pisteName, length, fall} *\newline
\underline{liftName, summit, rise}*\\[0.2cm]
(pisteName, length and fall refer to attributes in relation Piste. liftName, summit and rise refer to attributes in relation Lift)

\subsection{Third Normal Form}
For a database to be valid for Third Normal Form, it must first conform to 2NF, and also have no transitive dependencies. This requires that all non-key attributes rely upon only the PK, and nothing but the key, providing a fact about the PK and nothing else. If we look at our current relations, we can see that this is already the case.

Each attributes relies soley upon the Primary Key of its relation, and provides a fact about that Primary Key, providing no information about any other aspect of the database or of itself. From all this, we can see that Lift has been in 3NF throughout the whole process.

\newpage

\section{PostgreSQL}
With the data now in 3NF, it is suitable to be put into a database. For this task, it must be placed into a PostgreSQL table. I have created this on my personal filestore at Aberystwyth University. Below are the commands I used to create these, and screenshots to show the creation process.

\subsection{Creating the tables}

\subsection{Quering the Database}

\newpage

\begin{thebibliography}{9}

\bibitem{sample}
  Edel Sherratt,
  \emph{CS27020 Assignment: Ski Lifts and Pistes}.
  Computer Science Department,
  Aberystwyth University,
  2014.

\end{thebibliography}

\end{document}
